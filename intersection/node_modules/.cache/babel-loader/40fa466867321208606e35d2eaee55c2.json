{"ast":null,"code":"import * as R from 'ramda';\nexport const defaultColorObj = {\n  intersection: '#fff459',\n  mark: '#42d7f5'\n};\nexport const xAxis = items => {\n  const xScaleKey = 'x';\n  const getXLabels = R.pipe(R.flatten, R.sortBy(R.prop(xScaleKey)), R.map(R.prop(xScaleKey)), R.uniq);\n  const xLabels = getXLabels(items);\n  return xLabels;\n};\nexport const yAxis = items => {\n  const getYLabels = R.pipe(R.flatten, R.uniq);\n  const yLabels = getYLabels(items);\n  return yLabels.sort();\n};\nexport const normalize = R.pipe(R.unnest, R.map(({\n  items,\n  y,\n  color,\n  label\n}) => {\n  return R.map(R.pipe(R.assoc('y', y), R.assoc('color', color), R.assoc('label', label)), items);\n}), R.unnest);\nexport const getDatasource = dataRaw => {\n  return dataRaw.map(ds => ds.data);\n};\nexport const setAttributes = R.pipe(R.map(({\n  data,\n  color,\n  label\n}) => {\n  return R.map(R.pipe(R.assoc('color', color !== undefined ? color : defaultColorObj.mark), R.assoc('label', label)), data);\n}), R.unnest);\nexport const setLegendAttributes = (dataRaw, category) => {\n  var legendData = [];\n  dataRaw.map(row => {\n    legendData.push(R.pick([category, 'color'], row));\n  });\n  return legendData;\n};\nexport const intersections = circlesData => R.pipe(R.groupBy(({\n  y,\n  x\n}) => y + x), R.filter(R.compose(R.lt(1), R.length)), R.map(R.head), R.values)(circlesData);\nexport const defaultColor = (color, location) => {\n  var colorObj = {\n    [location]: color\n  };\n  return color !== undefined ? colorObj : defaultColorObj;\n};","map":{"version":3,"sources":["/Users/marinas/WORK/GIT/ReactD3-projects/React-projects/size_matrix/src/matrix/functions.js"],"names":["R","defaultColorObj","intersection","mark","xAxis","items","xScaleKey","getXLabels","pipe","flatten","sortBy","prop","map","uniq","xLabels","yAxis","getYLabels","yLabels","sort","normalize","unnest","y","color","label","assoc","getDatasource","dataRaw","ds","data","setAttributes","undefined","setLegendAttributes","category","legendData","row","push","pick","intersections","circlesData","groupBy","x","filter","compose","lt","length","head","values","defaultColor","location","colorObj"],"mappings":"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","sourcesContent":["import * as R from 'ramda';\n\nexport const defaultColorObj = {\n\t\tintersection:'#fff459',\n\t\tmark:'#42d7f5'\n\t};\n\nexport const xAxis = (items) => {\n\tconst xScaleKey = 'x';\n\n\tconst getXLabels = R.pipe(\n\t\tR.flatten,\n\t\tR.sortBy(R.prop(xScaleKey)),\n\t\tR.map(R.prop(xScaleKey)),\n\t\tR.uniq\n\t\t)\n\n\tconst xLabels = getXLabels(items);\n\treturn xLabels;\n};\nexport const yAxis = (items) => {\n\n\tconst getYLabels = R.pipe(\n\t\tR.flatten,\n\t\tR.uniq\n\t\t)\n\n\tconst yLabels = getYLabels(items);\n\treturn yLabels.sort();\n};\n\nexport const normalize = R.pipe(\n  R.unnest,\n  R.map(({items, y, color, label}) => {\n    return R.map(R.pipe(\n    \tR.assoc('y', y),\n    \tR.assoc('color', color),\n    \tR.assoc('label', label)\n    ), items)\n  }),\n  R.unnest\n);\n\nexport const getDatasource = (dataRaw) => {\n\t\treturn dataRaw.map(ds => (ds.data))\n};\n\nexport const setAttributes = R.pipe(\n\tR.map(({data, color, label}) => {\n\t\treturn R.map(R.pipe(\n\t\t\t\tR.assoc('color', (color!==undefined)?color:defaultColorObj.mark),\n\t\t\t\tR.assoc('label', label)), data)\n\t\t}\n\t),\n\tR.unnest\n);\n\nexport const setLegendAttributes = (dataRaw, category) => {\n\t\tvar legendData = [];\n\t\tdataRaw.map(row => {legendData.push(R.pick([category, 'color'], row));});\n\t\treturn legendData;\n};\n\nexport const intersections =(circlesData)=> R.pipe(\n\t    \tR.groupBy(({y, x}) => (y + x)),\n\t    \tR.filter(R.compose(R.lt(1), R.length)),\n\t    \tR.map(R.head),\n\t    \tR.values\n\t\t)(circlesData);\nexport const defaultColor=(color, location) =>{\n\t\tvar colorObj = {[location]: color};\n\t\treturn  (color!==undefined)?colorObj:defaultColorObj;\n};\n\n"]},"metadata":{},"sourceType":"module"}