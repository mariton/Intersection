{"ast":null,"code":"const xAxis = items => {\n  const xScaleKey = 'column';\n  const getXLabels = R.pipe(R.flatten, R.sortBy(R.prop(xScaleKey)), R.map(R.prop(xScaleKey)), R.uniq);\n  const xLabels = getXLabels(items);\n  return xLabels;\n};\n\nconst yAxis = items => {\n  const getYLabels = R.pipe(R.flatten, R.uniq);\n  const yLabels = getYLabels(items);\n  return yLabels.sort();\n};\n\nconst normalize = R.pipe(R.unnest, R.map(({\n  items,\n  rowKey,\n  color,\n  label\n}) => {\n  return R.map(R.pipe(R.assoc('rowKey', rowKey), R.assoc('color', color), R.assoc('label', label)), items);\n}), R.unnest);\n\nconst getDatasource = dataRaw => {\n  return dataRaw.map(ds => ds.data);\n};\n\nconst setAttributes = R.pipe(R.map(({\n  data,\n  color,\n  label\n}) => {\n  return R.map(R.pipe(R.assoc('color', color), R.assoc('label', label)), data);\n}), R.unnest);\n\nconst setLegendAttributes = (dataRaw, category) => {\n  var legendData = [];\n  dataRaw.map(row => {\n    legendData.push(R.pick([category, 'color'], row));\n  });\n  return legendData;\n};\n\nconst intersections = circlesData => R.pipe(R.groupBy(({\n  rowKey,\n  column\n}) => rowKey + column), R.filter(R.compose(R.lt(1), R.length)), R.map(R.head), R.values)(circlesData);","map":{"version":3,"sources":["/Users/marinas/WORK/GIT/ReactD3-projects/React-projects/size_matrix/src/matrix/functions.js"],"names":["xAxis","items","xScaleKey","getXLabels","R","pipe","flatten","sortBy","prop","map","uniq","xLabels","yAxis","getYLabels","yLabels","sort","normalize","unnest","rowKey","color","label","assoc","getDatasource","dataRaw","ds","data","setAttributes","setLegendAttributes","category","legendData","row","push","pick","intersections","circlesData","groupBy","column","filter","compose","lt","length","head","values"],"mappings":"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","sourcesContent":["const xAxis = (items) => {\n\tconst xScaleKey = 'column';\n\n\tconst getXLabels = R.pipe(\n\t\tR.flatten,\n\t\tR.sortBy(R.prop(xScaleKey)),\n\t\tR.map(R.prop(xScaleKey)),\n\t\tR.uniq\n\t\t)\n\n\tconst xLabels = getXLabels(items);\n\treturn xLabels;\n};\nconst yAxis = (items) => {\n\n\tconst getYLabels = R.pipe(\n\t\tR.flatten,\n\t\tR.uniq\n\t\t)\n\n\tconst yLabels = getYLabels(items)\n\treturn yLabels.sort();\n};\n\nconst normalize = R.pipe(\n  R.unnest,\n  R.map(({items, rowKey, color, label}) => {\n    return R.map(R.pipe(\n    \tR.assoc('rowKey', rowKey),\n    \tR.assoc('color', color),\n    \tR.assoc('label', label)\n    ), items)\n  }),\n  R.unnest\n);\n\nconst getDatasource = (dataRaw) => {\n\t\treturn dataRaw.map(ds => (ds.data))\n};\nconst setAttributes = R.pipe(\n\tR.map(({data, color, label}) => {\n\t\treturn R.map(R.pipe(\n\t\t\t\tR.assoc('color', color),\n\t\t\t\tR.assoc('label', label)), data)\n\t\t}\n\t),\n\tR.unnest\n);\n\nconst setLegendAttributes = (dataRaw, category) => {\n\t\tvar legendData = [];\n\t\tdataRaw.map(row => {legendData.push(R.pick([category, 'color'], row));});\n\t\treturn legendData;\n};\n\nconst intersections =(circlesData)=> R.pipe(\n\t    \tR.groupBy(({rowKey, column}) => (rowKey + column)),\n\t    \tR.filter(R.compose(R.lt(1), R.length)),\n\t    \tR.map(R.head),\n\t    \tR.values\n\t\t)(circlesData);"]},"metadata":{},"sourceType":"module"}